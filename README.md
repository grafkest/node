# Концепция приложения для визуализации модулей и доменных областей

## Запуск прототипа

В репозитории лежит интерактивный прототип на React с визуализацией графа, фильтрами и аналитикой. Ниже — пошаговый алгоритм, как собрать и протестировать проект с помощью Visual Studio Code.

### Настройка окружения

1. Установите [Node.js 18+](https://nodejs.org/en/download). Пакет включает менеджер пакетов `npm`, который используется во всех последующих шагах.
2. Установите [Visual Studio Code](https://code.visualstudio.com/) и запустите его.
3. Через стартовый экран VS Code выберите **Clone Git Repository…**, вставьте URL проекта и дождитесь окончания клонирования. Альтернативно можно открыть уже склонированную папку через **File → Open Folder…**.

### Сборка и запуск через VS Code

1. Откройте интегрированный терминал (горячая клавиша `Ctrl`+`` ` `` или меню **Terminal → New Terminal**). Терминал автоматически окажется в корне проекта. Убедитесь, что в строке состояния и в промпте терминала указан путь к каталогу, где лежит `package.json` (например, `…/domain-graph/`). Если сомневаетесь, выполните `dir` (Windows) или `ls` (macOS/Linux) и убедитесь, что в списке файлов есть `package.json` и `package-lock.json`.
2. Установите зависимости:

   ```bash
   npm install
   ```

3. Запустите сервис постоянного хранения графа в отдельном терминале:

   ```bash
   npm run server
   ```

   Сервер стартует на `http://localhost:4000` и создаст файл базы данных `data/graph.db`. При необходимости измените порт через переменную окружения `PORT` перед запуском.

4. Для локального тестирования интерфейса выполните команду разработки (в другом терминале):

   ```bash
   npm run dev
   ```

   VS Code покажет URL в терминале (по умолчанию `http://localhost:5173`). Зажмите `Ctrl` и кликните по ссылке, чтобы открыть приложение в браузере.

5. Чтобы собрать production-версию, используйте меню **Terminal → Run Task…**, выберите задачу `npm: build` или запустите команду вручную:

   ```bash
   npm run build
   ```

   Готовые статические файлы появятся в каталоге `dist/`.

6. Для проверки собранной версии локально выполните:

   ```bash
   npm run preview
   ```

   Команда стартует встроенный сервер Vite и выведет ссылку на предварительный просмотр.

7. По желанию запустите линтер перед коммитом:

   ```bash
   npm run lint
   ```

> Если терминал VS Code сообщает об отсутствии `npm`, убедитесь, что Node.js установлен и VS Code запущен после установки (перезапуск обновит переменные окружения).

### Частые ошибки

- **`npm ERR! enoent ENOENT: no such file or directory, open '…\package.json'`.** Команда выполнена не из корня проекта. Откройте в терминале каталог, где лежит файл `package.json`. Если вы распаковали архив, убедитесь, что зашли во вложенную папку `domain-graph` (иногда архивы добавляют дополнительный уровень вложенности, например `domain-graph-main\domain-graph`).
- **`npm` не является внутренней или внешней командой.** Node.js не установлен или VS Code был открыт до установки. Установите Node.js и перезапустите VS Code.
- **`gyp ERR!` при установке зависимостей (Python/Visual Studio).** Текущая версия хранилища использует `sql.js` и не требует нативной сборки. Обновите репозиторий и повторно выполните `npm install`.


## Постоянное хранение графа

- **Сервер на Express + SQLite (sql.js, без нативной сборки).** В репозитории появился сервис `npm run server`, который предоставляет REST API `/api/graph` для чтения и записи полного снапшота графа. Данные сохраняются в файл `data/graph.db`, а структура включает таблицы доменов, модулей и артефактов с порядковыми позициями.
- **Загрузка при старте.** Клиентское приложение запрашивает текущее состояние из базы и отображает индикатор статуса синхронизации. При недоступности сервера используются встроенные данные, но изменения не отправляются.
- **Автосохранение изменений.** После создания модулей, доменов или артефактов фронтенд отправляет обновлённый снапшот на сервер. Экспорт/импорт по-прежнему доступен для ручных бэкапов.


## Цель
В нефтегазовой компании десятки команд создают различные IT-продукты. Из-за отсутствия общей картины модули нередко дублируют друг друга. Цель веб-приложения — визуализировать модули и доменные области в виде графа, чтобы участники могли находить пересечения, избегать повторной разработки и переиспользовать существующие решения.

## Методология и роли

### Общие принципы
- **Граф знаний на основе онтологии.** Знание представляется как сеть сущностей и отношений, что позволяет находить скрытые связи и выполнять сложные запросы.
- **Стратегический и тактический DDD.** Ограниченные контексты определяют границы предметных областей, а тактический уровень задаёт сущности, агрегаты и сервисы.
- **Централизованное хранилище знаний.** Единая база документации и данных обеспечивает самостоятельный доступ к информации и снижает риск повторной разработки.
- **Итеративное развитие.** Онтология и граф пополняются и уточняются по мере появления новых знаний.

### Роли
| Роль | Ответственность |
| --- | --- |
| **Доменный эксперт** | Формирует структуру доменного дерева, валидирует связи между модулями и доменами. |
| **Аналитик / инженер по знаниям** | Собирает требования, проектирует онтологию, определяет атрибуты и поддерживает модели. |
| **Архитектор** | Определяет границы контекстов, стандарты интеграции и согласованность моделей. |
| **Разработчик / владелец модуля** | Описывает модуль, поддерживает актуальность данных. |
| **Ответственный за качество данных** | Организует ревизии, контролирует модульность и переиспользуемость. |

## Процесс наполнения
1. **Анализ домена.** Определение ключевых субдоменов и потенциальных интеграций.
2. **Формирование доменного дерева.** Построение иерархии областей с помощью онтологических инструментов.
3. **Описание модулей.** Добавление узлов типа «Модуль» с атрибутами и связями с доменами.
4. **Связывание модулей.** Моделирование зависимостей между компонентами.
5. **Ревизия и обновление.** Регулярное уточнение данных и связей.
6. **Обучение и обмен знаниями.** Мероприятия по поддержанию качества данных и распространению знаний.
7. **Использование базы.** Фильтрация и изучение модулей по выбранным доменам через веб-интерфейс.

## Уровни декомпозиции доменных областей
1. **Домен / ограниченный контекст.** Крупные предметные области с собственным языком и моделями (например, добыча, транспортировка, экономика).
2. **Поддомен / объект или процесс.** Ключевые сущности или процессы внутри контекста (скважина, бурение, мониторинг).
3. **Функция / модуль.** Конкретные программные компоненты, связанные с объектами и процессами через отношения «использует», «производит» или «зависит».

## Атрибуты сущностей

### Модуль
- Идентификатор
- Название
- Описание
- Доменные области
- Команда / владелец
- Репозиторий исходного кода
- API / интерфейсы
- Зависимости
- Статус
- Показатели
- Переиспользуемость

### Доменный объект или процесс
- Название
- Тип
- Родитель
- Описание
- Синонимы
- Владелец

### Отношения
- **Использует** — модуль использует доменный объект или другой модуль.
- **Производит** — модуль создаёт данные для доменного объекта.
- **Зависит** — модуль зависит от другого модуля.
- **Связан с** — произвольные дополнительные связи.

## Архитектурные компоненты
- **Хранилище графа.** RDF-триплстор (GraphDB, Stardog) или property-graph база (Neo4j) для хранения данных и выполнения запросов.
- **Слой бизнес-логики.** API для чтения и записи графа, валидация данных, правила доступа, поддержка REST/GraphQL/SPARQL.
- **Модуль импорта данных.** ETL/ELT-инструменты для загрузки описаний систем, автоматического извлечения сущностей и связей.
- **Веб-приложение.** Интерфейс на React с использованием Consta UI и Consta Charts, визуализация графа через Reagraph или альтернативы (Cytoscape.js, React Flow).

## Основные функции веб-приложения
1. Навигация по дереву доменов.
2. Поиск и фильтры по командам, статусам и типам связей.
3. Интерактивная карта графа с различными типами узлов и настройками визуализации.
4. Карточка узла с деталями и возможностью редактирования.
5. Формы добавления и изменения сущностей.
6. История изменений и обсуждения.
7. Аналитика и отчёты с использованием диаграмм.
8. Экспорт и импорт данных.

## Пользовательский сценарий
1. Аналитик выбирает доменные области «Скважины» и «Экономика» и видит связанные модули.
2. Обнаруживает дублирующие функции и сравнивает их параметры.
3. Инициирует обсуждение для объединения усилий.
4. После согласования обновляет граф и статусы модулей.

## Практики управления знаниями
- Ведение единой базы знаний и документации.
- Парное программирование и code review.
- Онбординг и наставничество.
- Кросс-командное взаимодействие.
- Регулярные ревизии процессов и данных.

## Технологический стек
- **GraphDB / Stardog** — для семантических моделей и reasoning.
- **Neo4j** — для высокопроизводительных property-графов (при необходимости с neosemantics).
- **Reagraph** или **Cytoscape.js / React Flow** — библиотеки визуализации графов.
- **Consta UI** и **Consta Charts** — дизайн-система и диаграммы.
- **Protégé / Grafo / WebVOWL** — инструменты моделирования онтологий.
- **Elasticsearch** — полнотекстовый поиск поверх графовой базы.

## Заключение
Комбинация онтологического моделирования, DDD и современных инструментов визуализации позволяет построить приложение, которое снижает дублирование, ускоряет поиск решений и развивает культуру обмена знаниями в организации.
